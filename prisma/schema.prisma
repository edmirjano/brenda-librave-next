// This is your Prisma schema file for BrÃ«nda Librave
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Note: For production deployment on Netlify, this will be automatically 
// configured to use PostgreSQL via Neon. See NETLIFY_DEPLOYMENT.md for setup.

// Authentication Models (NextAuth.js compatible)
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// User Management
model User {
  id              String    @id @default(cuid())
  email           String    @unique
  password        String?   // nullable for social auth
  name            String
  role            Role      @default(USER)
  newsletter      Boolean   @default(false)
  emailVerified   DateTime?
  image           String?
  
  // Relations
  accounts        Account[]
  sessions        Session[]
  cartItems       CartItem[]
  orders          Order[]
  
  blogPosts       BlogPost[]
  comments        Comment[]
  moderatedPosts  BlogPost[]   @relation("ModeratedPosts")
  blogPostLikes   BlogPostLike[]
  
  // Community features
  forumTopics     ForumTopic[]
  forumPosts      ForumPost[]
  wishlist        Wishlist[]
  collections     BookCollection[]
  readingHistory  ReadingHistory[]
  couponUsages    CouponUsage[]
  rentals         EbookRental[]
  accessLogs      EbookAccessLog[]
  hardcopyRentals HardcopyRental[]
  hardcopyLogs    HardcopyRentalLog[]
  userSubscriptions UserSubscription[]
  subscriptionAccessLogs SubscriptionAccessLog[]
  audioBookRentals AudioBookRental[]
  audioBookAccessLogs AudioBookAccessLog[]
  userTermsAcceptances UserTermsAcceptance[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
}

enum Role {
  USER
  ADMIN
}

enum Language {
  SQ
  EN
  IT
  DE
  FR
  TR
  MK
}

enum Currency {
  ALL  // Albanian Lek
  EUR  // Euro
}

// Settings for the application
model Setting {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String
  description String?  // Description for admin UI
  category    String   @default("general") // Category for grouping settings
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([category])
}

// Supported Languages (Dynamic)
model SupportedLanguage {
  id          String   @id @default(cuid())
  code        String   @unique // ISO 639-1 code (sq, en, it, de, etc.)
  name        String   // Language name in English
  nativeName  String   // Language name in native script
  direction   String   @default("ltr") // "ltr" or "rtl"
  isActive    Boolean  @default(true)
  isDefault   Boolean  @default(false)
  
  // SEO and cultural settings
  currency    Currency? // Preferred currency for this language
  timeZone    String?   // Default timezone
  dateFormat  String?   // Preferred date format
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@index([isActive])
  @@index([isDefault])
}

// Generic Translation System
model Translation {
  id          String   @id @default(cuid())
  namespace   String   // e.g., "book", "category", "ui", "metadata"
  key         String   // e.g., "title", "description", "name"
  language    String   // Language code (sq, en, it, etc.)
  value       String   // Translated text
  context     String?  // Additional context for translators
  
  // Reference to the original content
  entityType  String   // "Book", "Category", "Tag", "BlogPost", etc.
  entityId    String   // ID of the entity being translated
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([namespace, key, language, entityType, entityId])
  @@index([entityType, entityId])
  @@index([language])
  @@index([namespace])
}

// Currency Exchange Rates
model ExchangeRate {
  id           String   @id @default(cuid())
  fromCurrency Currency
  toCurrency   Currency
  rate         Float
  isActive     Boolean  @default(true)
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@unique([fromCurrency, toCurrency])
  @@index([isActive])
}

// Book Catalog Models
model Book {
  id              String    @id @default(cuid())
  slug            String    @unique
  
  // Core data (language-neutral)
  isbn            String?   @unique
  categoryId      String
  price           Float?    // Base price in Albanian Lek (for hardcopy)
  digitalPrice    Float?    // Digital price in Albanian Lek (for ebook)
  baseCurrency    Currency  @default(ALL) // Base currency for this book
  inventory       Int       @default(0) // Physical inventory for hardcopy
  hasDigital      Boolean   @default(false) // Has ebook version
  hasHardcopy     Boolean   @default(true)  // Has physical version
  digitalFileUrl  String?   // URL to the EPUB file (S3 or similar)
  digitalFileSize Int?      // File size in bytes
  coverImage      String?
  publishedDate   DateTime?
  baseLanguage    Language  @default(SQ) // Original language of the book
  featured        Boolean   @default(false)
  active          Boolean   @default(true)
  
  // Relations
  category        Category  @relation(fields: [categoryId], references: [id])
  tags            BookTag[]
  cartItems       CartItem[]
  orderItems      OrderItem[]
  
  // Community features
  forumTopics     ForumTopic[]
  wishlistItems   Wishlist[]
  collectionItems BookCollectionItem[]
  readingHistory  ReadingHistory[]
  rentals         EbookRental[]
  accessLogs      EbookAccessLog[]
  hardcopyRentals HardcopyRental[]
  hardcopyLogs    HardcopyRentalLog[]
  subscriptionBooks SubscriptionBook[]
  subscriptionAccessLogs SubscriptionAccessLog[]
  audioBooks AudioBook[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([active])
  @@index([featured])
  @@index([categoryId])
  @@index([slug])
}

model Category {
  id            String  @id @default(cuid())
  slug          String  @unique
  active        Boolean @default(true)
  
  // Relations
  books         Book[]
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  @@index([active])
  @@index([slug])
}

model Tag {
  id            String    @id @default(cuid())
  slug          String    @unique
  color         String?   // hex color for UI
  
  // Relations
  books         BookTag[]
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
  
  @@index([slug])
}

model BookTag {
  bookId    String
  tagId     String
  
  book      Book @relation(fields: [bookId], references: [id], onDelete: Cascade)
  tag       Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)
  
  @@id([bookId, tagId])
  @@index([bookId])
  @@index([tagId])
}

// E-commerce Models
model CartItem {
  id       String   @id @default(cuid())
  userId   String
  bookId   String
  quantity Int      @default(1)
  isDigital Boolean @default(false)
  currency Currency @default(ALL)
  
  user     User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book     Book @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@unique([userId, bookId, isDigital])
  @@index([userId])
  @@index([bookId])
}

model Order {
  id              String      @id @default(cuid())
  userId          String
  orderNumber     String      @unique
  status          OrderStatus @default(PENDING)
  totalAmount     Float       // Using Float for SQLite compatibility
  shippingCost    Float       @default(0)
  currency        Currency    @default(ALL)
  exchangeRate    Float?      // Exchange rate used at time of order
  
  // Shipping information
  shippingName    String
  shippingEmail   String
  shippingPhone   String
  shippingAddress String
  shippingCity    String
  shippingZip     String
  shippingCountry String
  
  // Payment information
  paymentMethod   PaymentMethod
  paymentId       String?     // PayPal transaction ID
  paidAt          DateTime?
  
  // Relations
  user            User        @relation(fields: [userId], references: [id])
  items           OrderItem[]
  couponUsage     CouponUsage?
  
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

model OrderItem {
  id        String  @id @default(cuid())
  orderId   String
  bookId    String
  quantity  Int
  price     Float   // Price at time of purchase
  currency  Currency @default(ALL)
  isDigital Boolean @default(false)
  isRental  Boolean @default(false) // New field for rental purchases
  
  order     Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
  book      Book  @relation(fields: [bookId], references: [id])
  rentals   EbookRental[] // Relation to rentals
  hardcopyRentals HardcopyRental[] // Relation to hardcopy rentals
  audioBookRentals AudioBookRental[] // Relation to audio book rentals
  
  createdAt DateTime @default(now())
  
  @@index([orderId])
  @@index([bookId])
}

enum OrderStatus {
  PENDING
  PAID
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  REFUNDED
}

enum PaymentMethod {
  PAYPAL
  STRIPE
  BANK_TRANSFER
}

// Coupon System
model Coupon {
  id                String      @id @default(cuid())
  code              String      @unique
  name              String
  description       String?
  type              CouponType
  value             Float       // Amount or percentage
  minimumAmount     Float?      // Minimum order amount
  maximumDiscount   Float?      // Maximum discount amount
  usageLimit        Int?        // Total usage limit
  usagePerUser      Int?        @default(1)
  usedCount         Int         @default(0)
  isActive          Boolean     @default(true)
  validFrom         DateTime
  validUntil        DateTime?
  applicableToBooks String      @default("[]") // JSON array of book IDs
  applicableToCategories String @default("[]") // JSON array of category IDs
  
  uses              CouponUsage[]
  
  createdAt         DateTime    @default(now())
  updatedAt         DateTime    @updatedAt
  
  @@index([code])
  @@index([isActive])
  @@index([validFrom, validUntil])
}

model CouponUsage {
  id        String   @id @default(cuid())
  couponId  String
  userId    String
  orderId   String   @unique
  discount  Float    // Discount amount applied
  
  coupon    Coupon   @relation(fields: [couponId], references: [id])
  user      User     @relation(fields: [userId], references: [id])
  order     Order    @relation(fields: [orderId], references: [id])
  
  createdAt DateTime @default(now())
  
  @@index([couponId])
  @@index([userId])
}

enum CouponType {
  PERCENTAGE
  FIXED_AMOUNT
  FREE_SHIPPING
  BUY_ONE_GET_ONE
}

// Blog System
model BlogPost {
  id              String        @id @default(cuid())
  title           String
  slug            String        @unique
  content         String
  excerpt         String?
  authorId        String
  categoryId      String?
  featuredImage   String?
  published       Boolean       @default(false)
  publishedAt     DateTime?
  language        Language      @default(SQ)
  type            BlogPostType  @default(ADMIN)
  status          BlogPostStatus @default(DRAFT)
  moderatedAt     DateTime?
  moderatedById   String?
  rejectionReason String?
  views           Int           @default(0)
  likes           Int           @default(0)

  // SEO fields
  metaTitle       String?
  metaDescription String?

  // Relations
  author          User          @relation(fields: [authorId], references: [id])
  category        BlogCategory? @relation(fields: [categoryId], references: [id])
  moderatedBy     User?         @relation("ModeratedPosts", fields: [moderatedById], references: [id])
  tags            BlogPostTag[]
  comments        Comment[]
  likes_relation  BlogPostLike[]

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([published])
  @@index([authorId])
  @@index([categoryId])
  @@index([type])
  @@index([status])
}

model BlogPostLike {
  id       String   @id @default(cuid())
  userId   String
  postId   String

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  post     BlogPost @relation(fields: [postId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, postId])
  @@index([postId])
}

enum BlogPostType {
  ADMIN     // Official blog posts by admin/staff
  USER      // User-generated content
  FEATURED  // Featured user posts
}

enum BlogPostStatus {
  DRAFT
  PENDING_REVIEW
  APPROVED
  REJECTED
  PUBLISHED
}

model BlogCategory {
  id          String     @id @default(cuid())
  name        String
  nameEn      String?
  slug        String     @unique
  description String?
  active      Boolean    @default(true)

  posts       BlogPost[]

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([active])
}

model BlogTag {
  id      String        @id @default(cuid())
  name    String        @unique
  nameEn  String?

  posts   BlogPostTag[]

  createdAt DateTime @default(now())
}

model BlogPostTag {
  postId String
  tagId  String

  post   BlogPost @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag    BlogTag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
}

model Comment {
  id        String        @id @default(cuid())
  content   String
  authorId  String
  postId    String
  parentId  String?       // For threaded comments
  status    CommentStatus @default(PENDING)

  author    User      @relation(fields: [authorId], references: [id])
  post      BlogPost  @relation(fields: [postId], references: [id], onDelete: Cascade)
  parent    Comment?  @relation("CommentReplies", fields: [parentId], references: [id])
  replies   Comment[] @relation("CommentReplies")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([postId])
  @@index([status])
}

enum CommentStatus {
  PENDING
  APPROVED
  REJECTED
  SPAM
}

// Community & Forum Models
model ForumCategory {
  id          String  @id @default(cuid())
  name        String
  nameEn      String?
  description String?
  slug        String  @unique
  color       String? // Hex color for category
  sortOrder   Int     @default(0)
  active      Boolean @default(true)

  topics      ForumTopic[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([active, sortOrder])
}

model ForumTopic {
  id          String      @id @default(cuid())
  title       String
  slug        String      @unique
  content     String
  authorId    String
  categoryId  String
  bookId      String?     // Optional: link to specific book
  pinned      Boolean     @default(false)
  locked      Boolean     @default(false)
  status      TopicStatus @default(ACTIVE)
  views       Int         @default(0)

  author      User         @relation(fields: [authorId], references: [id])
  category    ForumCategory @relation(fields: [categoryId], references: [id])
  book        Book?        @relation(fields: [bookId], references: [id])
  posts       ForumPost[]
  tags        ForumTopicTag[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([categoryId])
  @@index([authorId])
  @@index([bookId])
  @@index([status])
}

model ForumPost {
  id        String     @id @default(cuid())
  content   String
  authorId  String
  topicId   String
  parentId  String?    // For threaded replies
  status    PostStatus @default(ACTIVE)

  author    User       @relation(fields: [authorId], references: [id])
  topic     ForumTopic @relation(fields: [topicId], references: [id], onDelete: Cascade)
  parent    ForumPost? @relation("PostReplies", fields: [parentId], references: [id])
  replies   ForumPost[] @relation("PostReplies")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([topicId])
  @@index([authorId])
  @@index([status])
}

model ForumTag {
  id      String          @id @default(cuid())
  name    String          @unique
  nameEn  String?
  color   String?         // Hex color for tag

  topics  ForumTopicTag[]

  createdAt DateTime @default(now())
}

model ForumTopicTag {
  topicId String
  tagId   String

  topic   ForumTopic @relation(fields: [topicId], references: [id], onDelete: Cascade)
  tag     ForumTag   @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([topicId, tagId])
}

enum TopicStatus {
  ACTIVE
  LOCKED
  HIDDEN
  DELETED
}

enum PostStatus {
  ACTIVE
  HIDDEN
  DELETED
  FLAGGED
}

// User Collections & Wishlist
model Wishlist {
  id        String @id @default(cuid())
  userId    String
  bookId    String
  priority  Int    @default(1) // 1=low, 2=medium, 3=high
  notes     String?

  user      User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  book      Book   @relation(fields: [bookId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([userId, bookId])
  @@index([userId])
}

model BookCollection {
  id          String               @id @default(cuid())
  name        String
  description String?
  userId      String
  isPublic    Boolean              @default(false)

  user        User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  books       BookCollectionItem[]

  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt

  @@index([userId])
  @@index([isPublic])
}

model BookCollectionItem {
  id           String         @id @default(cuid())
  collectionId String
  bookId       String
  sortOrder    Int            @default(0)
  notes        String?

  collection   BookCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)
  book         Book           @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([collectionId, bookId])
  @@index([collectionId])
}

// Reading History & Progress
model ReadingHistory {
  id           String   @id @default(cuid())
  userId       String
  bookId       String
  startedAt    DateTime @default(now())
  progress     Int      @default(0) // Percentage 0-100
  completed    Boolean  @default(false)
  rating       Int?     // 1-5 stars
  
  // EPUB Reader specific fields
  currentCfi   String?  // Current reading position (EPUB CFI)
  lastReadAt   DateTime @default(now())
  readingTime  Int      @default(0) // Total reading time in minutes
  bookmarks    Json?    // JSON array of bookmarks with CFI positions
  highlights   Json?    // JSON array of highlighted text with CFI positions

  user         User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book         Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([userId, bookId])
  @@index([userId])
  @@index([lastReadAt])
}

// New Rental System Models
model EbookRental {
  id              String    @id @default(cuid())
  userId          String
  bookId          String
  orderItemId     String    // Reference to the purchase
  rentalType      RentalType
  rentalPrice     Float     // Price paid for rental
  currency        Currency  @default(ALL)
  startDate       DateTime  @default(now())
  endDate         DateTime  // When rental expires
  isActive        Boolean   @default(true)
  accessCount     Int       @default(0) // Number of times accessed
  lastAccessAt    DateTime?
  securityToken   String    @unique // Unique token for secure access
  watermarkData   Json?     // User-specific watermark data
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  book            Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  orderItem       OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  accessLogs      EbookAccessLog[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([userId])
  @@index([bookId])
  @@index([securityToken])
  @@index([isActive])
  @@index([endDate])
}

model EbookAccessLog {
  id              String    @id @default(cuid())
  rentalId        String
  userId          String
  bookId          String
  accessType      AccessType
  ipAddress       String?
  userAgent       String?
  sessionId       String?
  deviceFingerprint String? // Browser/device fingerprint
  suspiciousActivity Boolean @default(false)
  securityFlags   Json?     // Any security violations detected
  
  rental          EbookRental @relation(fields: [rentalId], references: [id], onDelete: Cascade)
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  book            Book        @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime   @default(now())
  
  @@index([rentalId])
  @@index([userId])
  @@index([bookId])
  @@index([accessType])
  @@index([suspiciousActivity])
}

enum RentalType {
  SINGLE_READ     // One-time access (like movie rental)
  TIME_LIMITED    // 24h, 48h, 7 days access
  UNLIMITED_READS // Unlimited reads within time period
}

enum AccessType {
  RENTAL_START
  RENTAL_READ
  RENTAL_END
  SECURITY_VIOLATION
  SUSPICIOUS_ACTIVITY
}

// Hardcopy Rental System Models
model HardcopyRental {
  id              String    @id @default(cuid())
  userId          String
  bookId          String
  orderItemId     String    // Reference to the purchase
  rentalType      HardcopyRentalType
  rentalPrice     Float     // Price paid for rental (e.g., 20 EUR)
  guaranteeAmount Float     // Guarantee/deposit amount (e.g., 200 EUR)
  currency        Currency  @default(ALL)
  startDate       DateTime  @default(now())
  endDate         DateTime  // When rental expires
  returnDate      DateTime? // Actual return date
  isActive        Boolean   @default(true)
  isReturned      Boolean   @default(false)
  isDamaged       Boolean   @default(false)
  damageNotes     String?   // Notes about any damage
  guaranteeRefunded Boolean @default(false)
  refundAmount    Float?    // Amount refunded (may be less than guarantee if damaged)
  
  // Book condition tracking
  initialCondition BookCondition @default(EXCELLENT)
  returnCondition  BookCondition?
  conditionNotes   String?   // Detailed condition notes
  
  // Shipping information
  shippingAddress String    // Delivery address
  trackingNumber  String?   // Shipping tracking number
  returnTracking  String?   // Return shipping tracking
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  book            Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  orderItem       OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  rentalLogs      HardcopyRentalLog[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([userId])
  @@index([bookId])
  @@index([isActive])
  @@index([isReturned])
  @@index([endDate])
}

model HardcopyRentalLog {
  id              String    @id @default(cuid())
  rentalId        String
  userId          String
  bookId          String
  logType         HardcopyRentalLogType
  description     String
  amount          Float?    // For financial transactions
  currency        Currency  @default(ALL)
  
  rental          HardcopyRental @relation(fields: [rentalId], references: [id], onDelete: Cascade)
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  book            Book        @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime   @default(now())
  
  @@index([rentalId])
  @@index([userId])
  @@index([bookId])
  @@index([logType])
}

enum HardcopyRentalType {
  SHORT_TERM      // 7 days
  MEDIUM_TERM     // 14 days
  LONG_TERM       // 30 days
  EXTENDED_TERM   // 60 days
}

enum HardcopyRentalLogType {
  RENTAL_CREATED
  BOOK_SHIPPED
  BOOK_DELIVERED
  RENTAL_EXTENDED
  RETURN_REQUESTED
  BOOK_RETURNED
  GUARANTEE_CHARGED
  GUARANTEE_REFUNDED
  DAMAGE_ASSESSED
  LATE_FEE_CHARGED
  RENTAL_COMPLETED
}

enum BookCondition {
  EXCELLENT    // Like new
  VERY_GOOD    // Minor wear
  GOOD         // Some wear but readable
  FAIR         // Significant wear
  POOR         // Damaged but usable
  DAMAGED      // Unusable
}

// Subscription System Models
model Subscription {
  id              String    @id @default(cuid())
  name            String    // e.g., "Premium Reader", "Student Plan"
  description     String?
  price           Float     // Monthly price
  currency        Currency  @default(ALL)
  duration        Int       // Duration in days (30, 90, 365)
  maxConcurrent   Int       @default(3) // Max books user can read simultaneously
  isActive        Boolean   @default(true)
  featured        Boolean   @default(false)
  
  // Subscription features
  includesEbooks  Boolean   @default(true)
  includesHardcopy Boolean  @default(false)
  unlimitedReads  Boolean   @default(true)
  prioritySupport Boolean   @default(false)
  
  // Book collection
  books           SubscriptionBook[]
  audioBooks      AudioBookSubscriptionBook[]
  
  // User subscriptions
  userSubscriptions UserSubscription[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([isActive])
  @@index([featured])
}

model SubscriptionBook {
  id             String    @id @default(cuid())
  subscriptionId String
  bookId         String
  addedAt        DateTime  @default(now())
  
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  book           Book         @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  @@unique([subscriptionId, bookId])
  @@index([subscriptionId])
  @@index([bookId])
}

model UserSubscription {
  id             String    @id @default(cuid())
  userId         String
  subscriptionId String
  startDate      DateTime  @default(now())
  endDate        DateTime  // When subscription expires
  isActive       Boolean   @default(true)
  autoRenew      Boolean   @default(true)
  paymentMethod  String?   // Payment method reference
  
  // Usage tracking
  totalReads     Int       @default(0)
  currentReads   Int       @default(0) // Books currently being read
  
  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscription   Subscription @relation(fields: [subscriptionId], references: [id])
  accessLogs     SubscriptionAccessLog[]
  audioBookAccessLogs AudioBookAccessLog[]
  
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  
  @@index([userId])
  @@index([subscriptionId])
  @@index([isActive])
  @@index([endDate])
}

model SubscriptionAccessLog {
  id                String    @id @default(cuid())
  userSubscriptionId String
  userId            String
  bookId            String
  accessType        SubscriptionAccessType
  sessionDuration   Int?      // Duration in minutes
  deviceInfo        String?   // Device/browser info
  ipAddress         String?
  
  userSubscription  UserSubscription @relation(fields: [userSubscriptionId], references: [id], onDelete: Cascade)
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  book              Book            @relation(fields: [bookId], references: [id], onDelete: Cascade)
  
  createdAt         DateTime  @default(now())
  
  @@index([userSubscriptionId])
  @@index([userId])
  @@index([bookId])
  @@index([accessType])
}

enum SubscriptionAccessType {
  BOOK_ACCESS_START
  BOOK_ACCESS_END
  READING_SESSION
  SECURITY_VIOLATION
  SUSPICIOUS_ACTIVITY
}

// Audio Book System Models
model AudioBook {
  id              String    @id @default(cuid())
  bookId          String    // Reference to the original book
  title           String
  author          String
  narrator        String    // Audio book narrator
  duration        Int       // Duration in seconds
  fileSize        Int       // File size in bytes
  audioFileUrl    String?   // URL to the audio file (S3 or similar)
  audioFileFormat String    @default("MP3") // MP3, AAC, etc.
  sampleUrl       String?   // Sample audio file URL
  price           Float?    // Audio book price
  digitalPrice    Float?    // Digital audio book price
  baseCurrency    Currency  @default(ALL)
  inventory       Int       @default(0) // For physical audio CDs
  hasDigital      Boolean   @default(true)
  hasPhysical     Boolean   @default(false)
  active          Boolean   @default(true)
  featured        Boolean   @default(false)
  
  // Audio book specific fields
  language        Language  @default(SQ)
  quality         AudioQuality @default(STANDARD)
  chapters        Int?      // Number of chapters
  chapterList     Json?     // Chapter timestamps and titles
  
  // Relations
  book            Book      @relation(fields: [bookId], references: [id], onDelete: Cascade)
  rentals         AudioBookRental[]
  accessLogs      AudioBookAccessLog[]
  subscriptionBooks AudioBookSubscriptionBook[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([bookId])
  @@index([active])
  @@index([featured])
  @@index([language])
}

model AudioBookRental {
  id              String    @id @default(cuid())
  userId          String
  audioBookId     String
  orderItemId     String
  rentalType      AudioBookRentalType
  rentalPrice     Float
  guaranteeAmount Float?    // For physical audio CDs
  currency        Currency  @default(ALL)
  startDate       DateTime  @default(now())
  endDate         DateTime
  returnDate      DateTime? // For physical rentals
  isActive        Boolean   @default(true)
  isReturned      Boolean   @default(false)
  isDamaged       Boolean   @default(false)
  damageNotes     String?
  guaranteeRefunded Boolean @default(false)
  refundAmount    Float?
  
  // Audio book specific tracking
  totalPlayTime   Int       @default(0) // Total seconds played
  lastPlayedAt    DateTime?
  playCount       Int       @default(0) // Number of times started
  completed       Boolean   @default(false) // Finished listening
  
  // Physical audio book tracking
  initialCondition AudioBookCondition @default(EXCELLENT)
  returnCondition  AudioBookCondition?
  conditionNotes   String?
  shippingAddress String?
  trackingNumber  String?
  returnTracking  String?
  
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  audioBook       AudioBook @relation(fields: [audioBookId], references: [id], onDelete: Cascade)
  orderItem       OrderItem @relation(fields: [orderItemId], references: [id], onDelete: Cascade)
  accessLogs      AudioBookAccessLog[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([userId])
  @@index([audioBookId])
  @@index([isActive])
  @@index([isReturned])
  @@index([endDate])
}

model AudioBookAccessLog {
  id              String    @id @default(cuid())
  rentalId        String?
  userSubscriptionId String?
  userId          String
  audioBookId     String
  accessType      AudioBookAccessType
  playTime        Int?      // Seconds played in this session
  sessionDuration Int?      // Total session duration in seconds
  deviceInfo      String?
  ipAddress       String?
  userAgent       String?
  suspiciousActivity Boolean @default(false)
  securityFlags   Json?
  
  rental          AudioBookRental? @relation(fields: [rentalId], references: [id], onDelete: Cascade)
  userSubscription UserSubscription? @relation(fields: [userSubscriptionId], references: [id], onDelete: Cascade)
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  audioBook       AudioBook   @relation(fields: [audioBookId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime   @default(now())
  
  @@index([rentalId])
  @@index([userSubscriptionId])
  @@index([userId])
  @@index([audioBookId])
  @@index([accessType])
  @@index([suspiciousActivity])
}

model AudioBookSubscriptionBook {
  id             String    @id @default(cuid())
  subscriptionId String
  audioBookId    String
  addedAt        DateTime  @default(now())
  
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  audioBook      AudioBook    @relation(fields: [audioBookId], references: [id], onDelete: Cascade)
  
  @@unique([subscriptionId, audioBookId])
  @@index([subscriptionId])
  @@index([audioBookId])
}

enum AudioBookRentalType {
  SINGLE_LISTEN    // One-time listen
  TIME_LIMITED     // 7 days access
  UNLIMITED_LISTENS // 30 days unlimited
}

enum AudioBookAccessType {
  RENTAL_START
  RENTAL_LISTEN
  RENTAL_END
  SUBSCRIPTION_ACCESS
  SECURITY_VIOLATION
  SUSPICIOUS_ACTIVITY
  PLAY_SESSION
  PAUSE_SESSION
  COMPLETE_LISTEN
}

enum AudioQuality {
  LOW        // 64kbps
  STANDARD   // 128kbps
  HIGH       // 256kbps
  ULTRA      // 320kbps
}

enum AudioBookCondition {
  EXCELLENT    // Like new
  VERY_GOOD    // Minor wear
  GOOD         // Some wear but playable
  FAIR         // Significant wear
  POOR         // Damaged but usable
  DAMAGED      // Unplayable
}

// Terms and Conditions System
model TermsAndConditions {
  id              String    @id @default(cuid())
  title           String    // e.g., "Ebook Rental Terms", "Audio Book Terms"
  version         String    // e.g., "1.0", "2.1"
  content         String    // Full terms and conditions text
  type            TermsType // Type of terms (rental, subscription, etc.)
  isActive        Boolean   @default(true)
  effectiveDate   DateTime  @default(now())
  expiryDate      DateTime? // When these terms expire
  
  // User acceptances
  userAcceptances UserTermsAcceptance[]
  
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt
  
  @@index([type])
  @@index([isActive])
  @@index([effectiveDate])
}

model UserTermsAcceptance {
  id                    String    @id @default(cuid())
  userId                String
  termsId               String
  acceptedAt            DateTime  @default(now())
  ipAddress             String?   // IP address when accepted
  userAgent             String?   // Browser/device info
  sessionId             String?   // Session identifier
  
  // Related to specific rental/subscription
  rentalType            RentalType? // For ebook rentals
  hardcopyRentalType   HardcopyRentalType? // For hardcopy rentals
  audioBookRentalType  AudioBookRentalType? // For audio book rentals
  subscriptionType      String?   // For subscriptions
  
  // Acceptance details
  readTime              Int?      // Time spent reading in seconds
  scrollDepth           Int?      // Percentage of terms scrolled
  confirmedRead         Boolean   @default(false) // User confirmed they read
  confirmedUnderstand   Boolean   @default(false) // User confirmed they understand
  
  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  terms                 TermsAndConditions @relation(fields: [termsId], references: [id], onDelete: Cascade)
  
  createdAt             DateTime  @default(now())
  
  @@index([userId])
  @@index([termsId])
  @@index([acceptedAt])
  @@index([rentalType])
  @@index([hardcopyRentalType])
  @@index([audioBookRentalType])
}

enum TermsType {
  EBOOK_RENTAL
  HARDCOPY_RENTAL
  AUDIO_BOOK_RENTAL
  SUBSCRIPTION
  GENERAL_RENTAL
  PRIVACY_POLICY
  DATA_PROTECTION
}